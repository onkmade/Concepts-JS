# Objects

### please read it carefully, this is an important concept for web development.
JavaScript objects are one of the most fundamental and powerful features of the language, especially for web development where you'll constantly work with data like user information, DOM elements, or API responses. At its core, an object in JavaScript is a collection of key-value pairs, where keys (also called properties) are strings (or symbols) and values can be anything: numbers, strings, arrays, functions, or even other objects. This makes objects incredibly flexible for modeling real-world data, such as representing a user on a website with properties like name, age, and email.

The simplest way to create an object is using **object literal notation**, which uses curly braces {}. For example, you can define an empty object like `const person = {};` or one with properties right away: `const person = { name: "Alex", age: 28, isDeveloper: true };`. This approach is perfect for beginners and common in web development for quick data structures, like configuration objects or data fetched from an API. Object literals are lightweight, readable, and great when you need just one unique instance of some data—no extra setup required.

To access or modify properties in an object, you have two main options: dot notation or bracket notation. Dot notation is cleaner and more common when you know the property name ahead of time, like `person.name` to get "Alex" or `person.age = 29` to update it. Bracket notation is useful for dynamic keys or when the key has spaces/special characters, such as `person["isDeveloper"]` or even `const key = "age"; person[key];`. In web development, you'll often use bracket notation when handling form data or JSON from servers, where keys might come from variables.

Objects can also hold functions, which are then called **methods** because they're attached to the object. For instance, add a method to greet: `const person = { name: "Alex", greet: function() { console.log(`Hello, I'm ${this.name}`); } };` Then call it with `person.greet();`. The special keyword `this` refers to the object itself, allowing the method to access other properties. This is crucial for interactive web apps, like creating reusable components that respond to user actions. Methods make objects behave like mini-programs, bundling data and behavior together—which is why objects are so central to JavaScript.

As you progress in web development, you'll encounter situations needing multiple similar objects, like a list of users. While you could copy object literals manually, that's inefficient. Instead, modern JavaScript (ES6 and later) provides **classes** as a cleaner way to create blueprints for objects. A class looks like this: `class Person { constructor(name, age) { this.name = name; this.age = age; } greet() { console.log(`Hello, I'm ${this.name}`); } }` Then instantiate with `const alex = new Person("Alex", 28); alex.greet();`. Classes are essentially syntactic sugar over JavaScript's prototype system, making code more readable and organized, especially for larger projects involving inheritance or many instances.

For most beginner web development tasks, start with object literals—they're simpler and sufficient for things like storing state in a small app or handling event data. As your apps grow (e.g., building a todo list with multiple items), transition to classes for better structure and reusability. Practice by opening your browser console and experimenting: create objects, add/remove properties with `delete person.age;`, or nest them like `const user = { profile: { name: "Alex" } };`. This hands-on approach will build your intuition quickly.

# Understanding: Creating and Accessing Objects
Even the DOM is the object! Document is the object, and all elements inside are objects too, except text nodes like "Hello World", which are just strings. Objects are like containers that hold related data and functions together. They help organize information in a way that makes it easy to access and manipulate

In JavaScript, everything in the DOM (Document Object Model) is built around objects.
The browser gives you a global object called `document` that represents the entire HTML page. This `document` object has many built-in methods like `getElementById()`, `querySelector()`, and `createElement()`. These are methods because they are functions attached to the `document` object.

When you select an element, like `const btn = document.getElementById("myButton");`, the variable `btn` now holds a reference to an HTML element object. That element object has its own properties (like `id`, `textContent`, `style`) and methods (like `click()`, `addEventListener()`). One useful property of an element object is `classList`, which itself is another object (a DOMTokenList). The `classList` object has methods such as `add()`, `remove()`, `toggle()`, and `contains()`. So `btn.classList.add("active")` means: on the `btn` object → access its `classList` property (an object) → call the `add` method on that object. This chaining of objects and methods is how the DOM works: objects contain properties, some properties are objects themselves, and those can have methods.

```javascript
// Example chain
document                  // global object
  .querySelector("button") // method → returns element object
  .classList               // property → DOMTokenList object
  .add("highlight");       // method on classList
```

In short: DOM gives you objects → objects have properties and methods → some properties are objects with their own methods → this structure lets you manipulate the webpage easily.


```javascript

        const book = {
            title: "The wings of Iceberg",
            author: "K.K kaur",
            genre: "Action, drama, Adventure",
            pages: 305,
            isRead: true
        };

        const person = {
            name: "Kiuru",
            age: 21,
            isAdult: true,
            greet: function(){
                return (`Hello, ${this.name}`);
            }
        };

        console.log(book.title); // dot notation
        console.log(book["author"]); // Bracket Notation
        console.log(book.pages, book.isRead);
        console.log(`The Book has ${book.title} by the author ${book.author} has genre, ${book.genre} and ${book.pages} pages.`); // Using Template Literal

        // Another program 
        console.log(person.greet()); // That's how you call the function

```

In JavaScript objects, a method is a function stored as a property.
Inside a method, use `this` to access the object's own properties.
Without `this`, JavaScript looks for a global variable, which causes errors.
Example bug: `return \Hello, ${name} \ → name` is undefined.
Fix: `return \Hello, ${this.name}\` → correctly gets "Kiuru".
You can also put `console.log` inside methods to print directly when called.

Key points:
`this` refers to the object (person) when the method is called.
Without `this`., JavaScript looks for a global variable `name` (which doesn’t exist).
Always use `this.propertyName` inside methods to access the object's own properties.
Also note: `console.log(person.greet)` `(without ())` will show the function itself, not the result.
Add () to call it: `console.log(person.greet()).`



--- 



## Add and Modifying Properties

Objects are mutable, meaning you can add, change, or delete properties after creation.
```js

// Adding and Modifiying the properties 
        const anime = {
            Title: "The One Piece",
            Author: "Ecchiro Oda",
            Genre: "Shonen",
            isRead: true,
            Season: 24,
            Episodes:1152
        };
        
        anime.Title = "The Legend of Hei";
        anime.Author = "Chinese author"
        anime.Episodes = "Movie" // Number converted to String

        console.log(`This ${anime.Title}, whose author is a ${anime.author}, which has ${anime.Episodes}`);
```

As you can see in the above example, we modified the properties of the object `anime` by simply assigning new values to existing keys. You can also add new properties in the same way:

```js
        // Adding new properties
        anime.ReleaseYear = 1999; // Try to add new property
        anime.Rating = "PG-13";

        console.log(anime);
```


---

## Deleting Properties
You can remove properties from an object using the `delete` operator.
```js
        // Deleting properties
        delete anime.isRead; // Removes the isRead property
        delete anime.Season; // Removes the Season property

        console.log(anime);
```
--- 

### nesting in objects means putting one object inside another as a property.

This lets you organize complex data, like grouping related information.

Example: a simple person object.

```js
const person = {
  name: "Kiuru",
  age: 21
};
```

Now, let's nest an address object inside it.

```js
const person = {
  name: "Kiuru",
  age: 21,
  address: {
    street: "123 Main St",
    city: "Helsinki",
    country: "Finland"
  }
};
```

The `address` is a property whose value is another object.

To access nested values, use multiple dots (or brackets).

```js
console.log(person.address.city);        // "Helsinki"
console.log(person["address"]["street"]); // "123 Main St"
```

You can nest deeper or add arrays too.

```js
const person = {
  name: "Kiuru",
  hobbies: ["coding", "reading"],
  contact: {
    email: "kiuru@example.com",
    phone: {
      home: "123-456",
      work: "789-012"
    }
  }
};

console.log(person.contact.phone.work);  // "789-012"
```

Nesting helps model real-world data cleanly—like users, products, or settings in web apps.

Practice: try creating a `student` object with nested `grades` and `school` objects!

Yes!
You can add a method to return the full nested address as a single string.
This keeps the data nested but gives easy access to a formatted version.

Example:

```js
const person = {
  name: "Kiuru",
  address: {
    street: "123 Main St",
    city: "Helsinki",
    country: "Finland"
  },
  fullAddress() {
    return `${this.address.street}, ${this.address.city}, ${this.address.country}`;
  }
};

console.log(person.fullAddress());
// Output: "123 Main St, Helsinki, Finland"
```

The method uses `this.address` to reach the nested object.
Then it accesses the inner properties with another dot.
Perfect for showing complete info without repeating data!
Try adding this method to your own nested object.